<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Flatfile Agent Chat</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f3f4f6;
      display: flex;
      justify-content: center;
      align-items: stretch;
      min-height: 100vh;
      padding: 18px;
    }

    .chat-wrapper {
      margin: 12px;
      background: #ffffff;
      border-radius: 14px;
      box-shadow: 0 10px 30px rgba(15, 23, 42, 0.12);
      display: flex;
      flex-direction: column;
      max-width: 900px;
      width: 100%;
      overflow: hidden;
      min-height: 560px;
    }

    header {
      padding: 14px 18px;
      background: #111827;
      color: #f9fafb;
      font-size: 16px;
      font-weight: 600;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    header span {
      font-size: 11px;
      opacity: 0.8;
    }

    #messages {
      flex: 1;
      padding: 18px;
      overflow-y: auto;
      background: linear-gradient(180deg, #f9fafb 0%, #fbfdff 100%);
    }

    .msg-row {
      margin-bottom: 12px;
      display: flex;
    }

    .msg-row.user {
      justify-content: flex-end;
    }

    .msg-row.agent {
      justify-content: flex-start;
    }

    .bubble {
      max-width: 72%;
      padding: 10px 14px;
      border-radius: 12px;
      font-size: 14px;
      line-height: 1.45;
      white-space: normal;
      word-wrap: break-word;
      box-shadow: 0 1px 0 rgba(0, 0, 0, 0.02);
    }

    .user .bubble {
      background: #2563eb;
      color: #fff;
      border-bottom-right-radius: 4px;
    }

    .agent .bubble {
      background: #e5e7eb;
      color: #111827;
      border-bottom-left-radius: 4px;
    }

    /* Upload area */
    #upload-area {
      padding: 12px 18px;
      border-top: 1px solid #e5e7eb;
      background: #ffffff;
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    #upload-area label {
      font-size: 13px;
      color: #374151;
      margin-right: 6px;
    }

    #file-input {
      cursor: pointer;
    }

    #upload-btn {
      border: none;
      background: #0ea5a4;
      color: #fff;
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
    }

    #upload-btn:disabled {
      opacity: 0.6;
      cursor: default;
    }

    #upload-status {
      font-size: 13px;
      color: #374151;
      margin-left: 8px;
    }

    /* Input area */
    #input-area {
      border-top: 1px solid #e5e7eb;
      padding: 10px 12px;
      display: flex;
      gap: 8px;
      background: #fff;
      align-items: center;
    }

    #user-input {
      flex: 1;
      border-radius: 8px;
      border: 1px solid #d1d5db;
      padding: 8px 10px;
      font-size: 14px;
      resize: none;
      max-height: 120px;
      min-height: 36px;
    }

    #send-btn {
      border: none;
      background: #16a34a;
      color: #fff;
      padding: 8px 18px;
      border-radius: 8px;
      font-size: 14px;
      cursor: pointer;
      min-width: 90px;
    }

    #send-btn:disabled {
      opacity: 0.6;
      cursor: default;
    }

    .download-btn {
      margin-top: 8px;
      padding: 6px 10px;
      border-radius: 8px;
      border: none;
      background: #1f2937;
      color: #fff;
      cursor: pointer;
      font-size: 13px;
    }

    .agent .bubble h2 {
      margin: 0 0 6px 0;
      font-size: 16px;
    }

    .agent .bubble h3 {
      margin: 6px 0 6px 0;
      font-size: 14px;
      font-weight: 700;
    }

    .agent .bubble p {
      margin: 6px 0;
    }

    .agent .bubble pre {
      margin: 6px 0;
      padding: 8px;
      border-radius: 8px;
      background: #111827;
      color: #f9fafb;
      overflow-x: auto;
      font-family: monospace;
      font-size: 13px;
    }

    .agent .bubble ul,
    .agent .bubble ol {
      margin: 6px 0 6px 18px;
    }

    @media (max-width: 540px) {
      .bubble {
        max-width: 88%;
      }

      #upload-area {
        padding: 10px;
      }
    }
  </style>
</head>

<body>
  <div class="chat-wrapper">
    <header>
      <div>Flatfile Agent Chat</div>
      <span>Azure AI Foundry</span>
    </header>

    <div id="messages" aria-live="polite"></div>

    <div id="upload-area">
      <label for="file-input">Upload CSV / XLSX</label>
      <input id="file-input" type="file" accept=".csv, .xlsx" />
      <button id="upload-btn">Upload</button>
      <span id="upload-status"></span>
    </div>

    <div id="input-area">
      <textarea id="user-input" rows="1"
        placeholder="Ask about data quality, profiling results, or datasets..."></textarea>
      <button id="send-btn">Send</button>
    </div>
  </div>

  <script>
    const messagesDiv = document.getElementById('messages');
    const input = document.getElementById('user-input');
    const sendBtn = document.getElementById('send-btn');

    const fileInput = document.getElementById('file-input');
    const uploadBtn = document.getElementById('upload-btn');
    const uploadStatus = document.getElementById('upload-status');

    // ---------- Simple safe inline formatter ----------
    function escapeHtml(str) {
      return str.replace(/[&<>"']/g, function (m) {
        return {
          '&': '&amp;',
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          "'": '&#39;'
        }[m];
      });
    }

    function formatInline(text) {
      const frag = document.createDocumentFragment();
      let parts = text.split('**');
      for (let i = 0; i < parts.length; i++) {
        const part = parts[i];
        if (i % 2 === 1) {
          const boldNode = document.createElement('strong');
          appendItalicFragments(boldNode, part);
          frag.appendChild(boldNode);
        } else {
          appendItalicFragments(frag, part);
        }
      }
      return frag;

      function appendItalicFragments(parent, str) {
        const italParts = str.split('*');
        for (let j = 0; j < italParts.length; j++) {
          const sub = italParts[j];
          if (j % 2 === 1) {
            const em = document.createElement('em');
            em.appendChild(document.createTextNode(sub));
            parent.appendChild(em);
          } else {
            parent.appendChild(document.createTextNode(sub));
          }
        }
      }
    }

    // ---------- Block-level parser ----------
    function renderFormatted(text) {
      const lines = String(text).replace(/\r/g, '').split('\n');
      const container = document.createDocumentFragment();

      let i = 0;
      let listBuffer = null;
      let inCode = false;
      let codeLines = [];

      while (i < lines.length) {
        const raw = lines[i];
        const line = raw.trim();

        if (line.startsWith('```')) {
          if (!inCode) {
            inCode = true;
            codeLines = [];
          } else {
            const pre = document.createElement('pre');
            pre.textContent = codeLines.join('\n');
            container.appendChild(pre);
            inCode = false;
            codeLines = [];
          }
          i++;
          continue;
        }

        if (inCode) {
          codeLines.push(raw);
          i++;
          continue;
        }

        if (line.startsWith('## ')) {
          flushList();
          const h2 = document.createElement('h2');
          h2.appendChild(formatInline(line.substring(3)));
          container.appendChild(h2);
          i++;
          continue;
        }
        if (line.startsWith('### ')) {
          flushList();
          const h3 = document.createElement('h3');
          h3.appendChild(formatInline(line.substring(4)));
          container.appendChild(h3);
          i++;
          continue;
        }

        if (line.startsWith('- ')) {
          if (!listBuffer || listBuffer.type !== 'ul') {
            flushList();
            const ul = document.createElement('ul');
            listBuffer = { type: 'ul', node: ul };
          }
          const li = document.createElement('li');
          li.appendChild(formatInline(raw.replace(/^- /, '')));
          listBuffer.node.appendChild(li);
          i++;
          continue;
        }

        if (/^\d+\.\s+/.test(line)) {
          if (!listBuffer || listBuffer.type !== 'ol') {
            flushList();
            const ol = document.createElement('ol');
            listBuffer = { type: 'ol', node: ol };
          }
          const li = document.createElement('li');
          li.appendChild(formatInline(raw.replace(/^\d+\.\s+/, '')));
          listBuffer.node.appendChild(li);
          i++;
          continue;
        }

        if (line === '') {
          flushList();
          i++;
          continue;
        }

        flushList();
        const p = document.createElement('p');
        p.appendChild(formatInline(raw));
        container.appendChild(p);
        i++;
      }

      if (inCode) {
        const pre = document.createElement('pre');
        pre.textContent = codeLines.join('\n');
        container.appendChild(pre);
      }

      flushList();

      return container;

      function flushList() {
        if (listBuffer) {
          container.appendChild(listBuffer.node);
          listBuffer = null;
        }
      }
    }

    // ---------- Messaging UI ----------
    function appendMessage(role, text, meta) {
      const row = document.createElement('div');
      row.className = 'msg-row ' + role;
      const bubble = document.createElement('div');
      bubble.className = 'bubble';

      if (role === 'agent' && text) {
        bubble.appendChild(renderFormatted(text));
        bubble.appendChild(document.createElement('div'));

        const downloadBtn = document.createElement('button');
        downloadBtn.className = 'download-btn';
        downloadBtn.textContent = 'Download PDF';
        downloadBtn.onclick = async () => {
          try {
            downloadBtn.disabled = true;
            downloadBtn.textContent = 'Preparing...';

            const resp = await fetch('/download_pdf', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ text })
            });

            if (!resp.ok) {
              const err = await resp.json().catch(() => ({ error: resp.statusText }));
              alert('Failed to generate PDF: ' + (err.error || resp.statusText));
              downloadBtn.disabled = false;
              downloadBtn.textContent = 'Download PDF';
              return;
            }

            const blob = await resp.blob();
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'agent_response.pdf';
            document.body.appendChild(a);
            a.click();
            a.remove();
            window.URL.revokeObjectURL(url);
            downloadBtn.disabled = false;
            downloadBtn.textContent = 'Download PDF';
          } catch (err) {
            alert('Network error: ' + (err.message || err));
            downloadBtn.disabled = false;
            downloadBtn.textContent = 'Download PDF';
          }
        };
        bubble.appendChild(downloadBtn);
      } else {
        const p = document.createElement('p');
        p.appendChild(document.createTextNode(text || ''));
        bubble.appendChild(p);
      }

      if (meta && meta.link) {
        const linkWrap = document.createElement('div');
        linkWrap.style.marginTop = '8px';
        const a = document.createElement('a');
        a.href = meta.link;
        a.textContent = meta.link;
        a.target = '_blank';
        a.rel = 'noopener noreferrer';
        a.style.fontSize = '13px';
        a.style.color = '#065f46';
        linkWrap.appendChild(a);
        bubble.appendChild(linkWrap);
      }

      row.appendChild(bubble);
      messagesDiv.appendChild(row);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    // initial greeting example
    appendMessage('agent', "Hi â€” I can help with data quality, profiling results or datasets. You can also upload a CSV/XLSX to store in blob storage.\n\nExamples:\n## Executive Summary\n- **Completeness**: Null values are present\n- **Consistency**: Several columns have format mismatches\n\n| Column | Issue | Percent |\n| --- | --- | --- |\n| customer_id | nulls | 12% |\n| address | inconsistent formatting | 8% |\n\n```sql\nSELECT * FROM customers WHERE customer_id IS NULL;\n```");

    async function sendMessage() {
      const text = input.value.trim();
      if (!text) return;
      appendMessage('user', text);
      input.value = '';
      input.focus();
      sendBtn.disabled = true;

      const thinkingRow = document.createElement('div');
      thinkingRow.className = 'msg-row agent';
      const thinkingBubble = document.createElement('div');
      thinkingBubble.className = 'bubble';
      thinkingBubble.textContent = 'Thinking...';
      thinkingRow.appendChild(thinkingBubble);
      messagesDiv.appendChild(thinkingRow);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;

      try {
        const res = await fetch('/chat', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ message: text })
        });
        const data = await res.json();
        messagesDiv.removeChild(thinkingRow);
        if (res.ok) {
          appendMessage('agent', data.reply || '[No reply]');
        } else {
          appendMessage('agent', 'Error: ' + (data.error || 'Unknown error'));
        }
      } catch (err) {
        messagesDiv.removeChild(thinkingRow);
        appendMessage('agent', 'Network error: ' + (err.message || err));
      } finally {
        sendBtn.disabled = false;
      }
    }

    sendBtn.addEventListener('click', sendMessage);
    input.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });

    uploadBtn.addEventListener('click', async () => {
      const file = fileInput.files[0];
      uploadStatus.textContent = '';
      if (!file) {
        uploadStatus.textContent = 'Choose a file first.';
        return;
      }
      const allowed = ['.csv', '.xlsx'];
      const name = file.name.toLowerCase();
      const okExt = allowed.some(ext => name.endsWith(ext));
      if (!okExt) {
        uploadStatus.textContent = 'Only .csv and .xlsx files are allowed.';
        return;
      }
      const maxBytes = 10 * 1024 * 1024;
      if (file.size > maxBytes) {
        uploadStatus.textContent = 'File too large (max 10 MB).';
        return;
      }

      uploadBtn.disabled = true;
      uploadStatus.textContent = 'Uploading...';
      const form = new FormData();
      form.append('file', file);

      try {
        const resp = await fetch('/upload', { method: 'POST', body: form });
        const data = await resp.json();
        if (resp.ok) {
          uploadStatus.textContent = 'Upload successful';
          if (data.blob_url) {
            appendMessage('agent', `Uploaded file: ${data.filename}`, { link: data.blob_url });
          } else {
            appendMessage('agent', `Uploaded file: ${data.filename}`);
          }
        } else {
          uploadStatus.textContent = 'Upload failed: ' + (data.error || 'Server error');
          appendMessage('agent', 'Upload failed: ' + (data.error || 'Server error'));
        }
      } catch (err) {
        uploadStatus.textContent = 'Network error: ' + err.message;
        appendMessage('agent', 'Network error: ' + err.message);
      } finally {
        uploadBtn.disabled = false;
      }
    });

    function autosize(el) {
      el.style.height = 'auto';
      el.style.height = (el.scrollHeight) + 'px';
    }
    input.addEventListener('input', () => autosize(input));
    autosize(input);
  </script>
</body>

</html>